// Maze rendering using HTML5 Canvas
window.mazeRenderer = {
    /**
     * Renders a maze to a canvas and returns the data URL
     * @param {Object} mazeData - The maze render data
     * @returns {string} - Data URL of the rendered image
     */
    renderMaze: function(mazeData) {
        const cellSize = 40;
        const wallThickness = 3;
        const margin = 60;
        const watermarkText = "Generated by mazegenerator.amanr.me";
        
        const width = mazeData.columns * cellSize + margin * 2;
        const height = mazeData.rows * cellSize + margin * 2;
        
        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // Clear background to white
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
        
        // Draw cells
        mazeData.cells.forEach(cell => {
            const x = margin + cell.column * cellSize;
            const y = margin + cell.row * cellSize;
            
            // Fill cell based on type
            if (cell.cellType === 'start') {
                ctx.fillStyle = '#90EE90'; // Light green
                ctx.fillRect(x, y, cellSize, cellSize);
            } else if (cell.cellType === 'end') {
                ctx.fillStyle = '#FFB6C1'; // Light pink
                ctx.fillRect(x, y, cellSize, cellSize);
            }
        });
        
        // Draw walls
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = wallThickness;
        ctx.lineCap = 'square';
        
        mazeData.cells.forEach(cell => {
            const x = margin + cell.column * cellSize;
            const y = margin + cell.row * cellSize;
            
            // Draw top wall
            if (cell.hasTopWall) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + cellSize, y);
                ctx.stroke();
            }
            
            // Draw right wall
            if (cell.hasRightWall) {
                ctx.beginPath();
                ctx.moveTo(x + cellSize, y);
                ctx.lineTo(x + cellSize, y + cellSize);
                ctx.stroke();
            }
            
            // Draw bottom wall
            if (cell.hasBottomWall) {
                ctx.beginPath();
                ctx.moveTo(x, y + cellSize);
                ctx.lineTo(x + cellSize, y + cellSize);
                ctx.stroke();
            }
            
            // Draw left wall
            if (cell.hasLeftWall) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + cellSize);
                ctx.stroke();
            }
        });
        
        // Draw watermark
        ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
        ctx.font = '14px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(watermarkText, width / 2, height - 20);
        
        // Return data URL
        return canvas.toDataURL('image/jpeg', 0.95);
    }
};
